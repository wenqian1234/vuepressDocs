(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{347:function(e,o,t){e.exports=t.p+"assets/img/image-20210115094046883.9b63fe0e.png"},363:function(e,o,t){"use strict";t.r(o);var n=t(40),a=Object(n.a)({},(function(){var e=this,o=e.$createElement,n=e._self._c||o;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("p",[e._v("单点登录实现方式")]),e._v(" "),n("p",[e._v("逻辑：")]),e._v(" "),n("p",[e._v("1.用户统一在认证中心进行登录，登录成功之后，认证中心负责登录和分发token")]),e._v(" "),n("p",[e._v("​\t\t通过iframe.contentWindow.postMessage分发token")]),e._v(" "),n("p",[e._v("2.子系统使用localStorage存储token，请求接口时带上token。检查当前请求有没有token,如果没有，说明用户在当前系统中尚未登录，那么就将页面跳转至认证中心。由于这个操作会将认证中心的localStorage自动带过去，因此，认证中心能够根据LocalStorage知道用户是否已经登录过了。如果认证中心发现用户尚未登录，则返回登录页面，等待用户登录，如果发现用户已经登录过了，就不会让用户再次登录了，而是会跳转回子系统的 URL ，并在跳转前生成一个 Token，拼接在子系统 URL 的后面，回传给子系统。")]),e._v(" "),n("p",[e._v("3.接口内部添加token统一验证逻辑，子系统获得token之后，还需要向认证中心确认下token的合法性，防止用户伪造。确认无误后，子系统记录用户的登录状态，并将token写入localStorage，然后给本次访问放行。当用户再次访问子系统时，就会自动带上这个 Token，应用系统验证 Token 发现用户已登录，于是就不会有认证中心什么事了。")]),e._v(" "),n("p",[e._v("4.token过期，给前端返回错误码；前端根据错误码，再次请求认证中心登录+获取token\n"),n("img",{attrs:{src:t(347),alt:""}})]),e._v(" "),n("p",[e._v("实现单点登录，跨域可以使用localStorage postMessage和iframe解决。")]),e._v(" "),n("p",[e._v("sessionStorage是会话级别的，标签关闭就没有了， 而且只能在当前标签内使用。")]),e._v(" "),n("p",[e._v("localStorage是持久化数据")]),e._v(" "),n("p",[e._v("对loginInfo做的处理,将loginInfo并存入到sessionStorage中,每次读取登录信息用getItem从loginInfo获取")]),e._v(" "),n("p",[e._v("loginSuccessHandler= ( ) =>{")]),e._v(" "),n("p",[e._v("​\tsessionStorage.setItem('login','true');")]),e._v(" "),n("p",[e._v("​\tlet loginInfo = sessionStorage.getItem('loginInfo');")]),e._v(" "),n("p",[e._v("​\tGlobalInfo.initLoginInfo(JSON.parse(loginInfo));")]),e._v(" "),n("p",[e._v("​\tthis.props.history.push('/main');")]),e._v(" "),n("p",[e._v("}")]),e._v(" "),n("p",[e._v("如果登录成功并且设置为记住密码，则把登录信息存入到localStorage中，以后从localStorage中获取数据即可，如果不设记住密码，localStorage里的密码字段为空，则每次进入时都要输入密码。")]),e._v(" "),n("p",[e._v("1.获取一个不可见的iframe（项目中是frame）")]),e._v(" "),n("p",[e._v("var frame = document.getElementById('iframe-' + CurrentModule.moduleId)")]),e._v(" "),n("p",[e._v('2.使用postMessage()方法将parame传递给iframe传送跨域数据\nframe.contentWindow.postMessage(param,data.origin)\npostMessage可以通过绑定window的message把登录态传递给子系统页面，实现跨文档消息传输，用于解决以下问题：\n　a.） 页面和其打开的新窗口的数据传递\n　b.） 多窗口之间消息传递\n　c.） 页面与嵌套的iframe消息传递\n　d.） 上面三个场景的跨域数据传递\n用法：\npostMessage(data,origin)方法接受两个参数：\ndata：任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。\norigin： 协议+主机+端口号，也可以设置为"*"，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为"/"。')]),e._v(" "),n("p",[e._v("前端通过iframe+postMessage()方式，将同一份Token写入到了多个域下的LocalStorage中，前端每次在向后端发送请求之前，都会主动从LocalStorage中读取Token并在请求中携带，这样就实现了同一份Token被多个域所共享。")]),e._v(" "),n("p",[e._v("认证中心+localStorage存储登录信息，生成token，postMessage和iframe分发token。")]),e._v(" "),n("p",[e._v("通过this.setstate()函数里设定时间通过触发一次组件的更新来引发重绘进行同步更新组件。\n....\nthis.setState({errorMsg:err.message});\n},3000);")]),e._v(" "),n("p",[e._v("3.子系统添加事件监听器监听发送的数据")]),e._v(" "),n("p",[e._v("window.addEventListener('message',function(e){")]),e._v(" "),n("p",[e._v("})")]),e._v(" "),n("p",[e._v("4.token过期，给前端返回错误码；前端根据错误码，再次请求认证中心登录+获取token")]),e._v(" "),n("p",[e._v("sessionStorage是会话级别的，标签关闭就没有了， 而且只能在当前标签内使用。")]),e._v(" "),n("p",[e._v("localStorage是持久化数据")]),e._v(" "),n("p",[e._v("对loginInfo做的处理,将loginInfo并存入到sessionStorage中,每次读取登录信息用getItem从loginInfo获取")])])}),[],!1,null,null,null);o.default=a.exports}}]);